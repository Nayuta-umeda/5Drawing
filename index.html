<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#6a7cff" />
  <title>5秒アニメ（みんなで）</title>
  <style>
    :root{
      color-scheme: light;
      --bg:#f6f7ff;
      --ink:#141428;
      --line:rgba(20,20,40,.10);
      --shadow: 0 14px 34px rgba(26,26,60,.14);
      --a:#6a7cff;
      --p:#ff5cc8;
      --m:#35d6c4;
      --y:#ffd34a;
      --r:#ff486a;
      --R:18px;
      --onionOpacity:.20;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(106,124,255,.18), transparent 55%),
        radial-gradient(900px 500px at 90% 20%, rgba(255,92,200,.14), transparent 55%),
        radial-gradient(900px 700px at 30% 95%, rgba(53,214,196,.12), transparent 55%),
        var(--bg);
      color:var(--ink);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;
      -webkit-font-smoothing: antialiased;
      overflow:hidden;
    }
    .app{
      height: 100vh;
      height: 100dvh;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      background: rgba(255,255,255,.88);
      border: 1px solid var(--line);
      border-radius: var(--R);
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
      min-height: 60px;
    }
    .left{ display:flex; flex-direction:column; gap:4px; min-width:0; }
    .title{ font-weight: 1000; letter-spacing:.06em; font-size: 14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .themeLine{ font-weight: 900; font-size: 12px; color: rgba(20,20,40,.78); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .right{ display:flex; align-items:center; gap:8px; flex-shrink:0; flex-wrap:wrap; justify-content:flex-end; }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.92);
      border: 1px solid var(--line);
      box-shadow: 0 10px 22px rgba(26,26,60,.10);
      font-weight: 1000;
      font-size: 13px;
      white-space:nowrap;
    }
    .dot{ width:10px; height:10px; border-radius:99px; background: rgba(20,20,40,.25); }
    .dot.on{ background: rgba(53,214,196,.95); }
    .dot.bad{ background: rgba(255,72,106,.95); }

    main{ flex:1; min-height:0; display:flex; flex-direction:column; gap:10px; }

    .stage{
      flex:0 0 auto;
      height:54vh;
      height:54dvh;
      min-height:320px;
      max-height:580px;
      border-radius: var(--R);
      border: 1px solid rgba(20,20,40,.12);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      aspect-ratio: 1 / 1;
      background-image:
        linear-gradient(rgba(20,20,40,.045) 1px, transparent 1px),
        linear-gradient(90deg, rgba(20,20,40,.045) 1px, transparent 1px);
      background-size:16px 16px;
      background-position:center;
    }
    .stage canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      image-rendering: pixelated;
      display:block;
    }
    #draw{ z-index:2; touch-action:none; }
    #onion{ z-index:3; pointer-events:none; opacity: var(--onionOpacity); }
    #play{ z-index:4; display:none; pointer-events:none; }
    .stage.preview #play{ display:block; }
    .stage.preview #draw{ pointer-events:none; }
    .stage.preview #onion{ opacity: 0; }

    .badge{
      position:absolute;
      top:10px;
      left:10px;
      z-index:10;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(20,20,40,.12);
      background: rgba(255,255,255,.90);
      backdrop-filter: blur(4px);
      box-shadow: 0 12px 26px rgba(26,26,60,.18);
      font-weight: 1000;
      letter-spacing:.06em;
      font-size: 16px;
    }

    .panel{
      flex:1;
      min-height:0;
      background: rgba(255,255,255,.88);
      border: 1px solid var(--line);
      border-radius: var(--R);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      backdrop-filter: blur(6px);
    }
    .tab{ flex:1; min-height:0; overflow:auto; padding:10px; display:none; }
    .tab.on{ display:block; }

    .bar{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:8px;
      padding:10px;
      border-top: 1px solid rgba(20,20,40,.08);
      background: rgba(255,255,255,.74);
    }
    .tbtn{
      padding:10px 8px;
      border-radius:14px;
      border: 1px solid rgba(20,20,40,.10);
      background: rgba(255,255,255,.98);
      color: rgba(20,20,40,.72);
      font-weight: 1000;
      font-size: 13px;
      letter-spacing:.04em;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      box-shadow: 0 10px 22px rgba(26,26,60,.10);
    }
    .tbtn.on{
      background: linear-gradient(135deg, rgba(106,124,255,.22), rgba(255,92,200,.14));
      border-color: rgba(106,124,255,.28);
      color: rgba(20,20,40,.95);
    }

    .box{
      background: rgba(255,255,255,.97);
      border: 1px solid rgba(20,20,40,.10);
      border-radius: 16px;
      padding:10px;
      box-shadow: 0 12px 26px rgba(26,26,60,.10);
    }
    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ flex:1; min-width:0; }
    .btn{
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(20,20,40,.12);
      background:#fff;
      color: rgba(20,20,40,.95);
      font-size: 15px;
      font-weight: 1000;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      box-shadow: 0 12px 26px rgba(26,26,60,.12);
    }
    .btn.ok{ background: linear-gradient(135deg, rgba(53,214,196,.28), rgba(106,124,255,.18)); border-color: rgba(53,214,196,.30); }
    .btn.sub{ background: rgba(255,255,255,.98); }
    .btn.bad{ background: linear-gradient(135deg, rgba(255,72,106,.22), rgba(255,211,74,.18)); border-color: rgba(255,72,106,.28); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    .mini{ font-weight: 900; font-size: 12px; color: rgba(20,20,40,.75); margin: 0 0 8px 2px; letter-spacing:.02em; }

    input[type="range"]{ width:100%; }
    input[type="color"]{
      width:100%;
      height:48px;
      border-radius:16px;
      border: 1px solid rgba(20,20,40,.12);
      background:#fff;
      padding:6px;
      box-shadow: 0 12px 26px rgba(26,26,60,.10);
    }
    input[type="text"], input[type="url"]{
      width:100%;
      height:44px;
      border-radius:16px;
      border:1px solid rgba(20,20,40,.12);
      padding:0 12px;
      font-weight:900;
      font-size:14px;
      box-shadow: 0 12px 26px rgba(26,26,60,.08);
      outline:none;
    }

    .grid2{ display:grid; grid-template-columns: .9fr 1.1fr; gap:10px; align-items:center; }

    .back{
      position:fixed;
      inset:0;
      background: rgba(20,20,40,.35);
      backdrop-filter: blur(3px);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:12px;
      z-index:50;
    }
    .back.on{ display:flex; }
    .sheet{
      width: min(980px, 100%);
      max-height: 80vh;
      max-height: 80dvh;
      background: rgba(255,255,255,.97);
      border: 1px solid rgba(20,20,40,.12);
      border-radius: 22px;
      box-shadow: 0 30px 80px rgba(26,26,60,.22);
      overflow:hidden;
    }
    .sheetTop{
      padding: 12px 12px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom: 1px solid rgba(20,20,40,.10);
      font-weight: 1000;
      letter-spacing:.06em;
    }
    .sheetGrid{
      padding:12px;
      display:grid;
      grid-template-columns: repeat(10, 1fr);
      gap:8px;
    }
    .f{
      height:34px;
      border-radius:12px;
      border: 1px solid rgba(20,20,40,.12);
      background: rgba(255,255,255,.98);
      font-weight: 1000;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(26,26,60,.10);
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .f.on{ outline:2px solid rgba(106,124,255,.90); outline-offset:1px; }
    .f.empty{ opacity:.65; }

    .toast{
      position:fixed;
      left:12px;
      right:12px;
      bottom: calc(12px + env(safe-area-inset-bottom));
      z-index:90;
      display:none;
      justify-content:center;
      pointer-events:none;
    }
    .toast.on{ display:flex; }
    .toast .t{
      max-width: 980px;
      width: 100%;
      background: rgba(255,255,255,.92);
      border:  1px solid rgba(20,20,40,.12);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 20px 60px rgba(26,26,60,.24);
      font-weight: 1000;
      color: rgba(20,20,40,.90);
      text-align:center;
    }

    @media (max-height: 720px){
      .stage{ min-height: 280px; height: 52vh; height: 52dvh; }
      header{ min-height: 56px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="left">
        <div class="title">5秒アニメ（みんなで）</div>
        <div class="themeLine" id="themeLine">お題：-</div>
      </div>
      <div class="right">
        <div class="chip" id="chipKoma">コマ 1 / 60</div>
        <div class="chip" id="chipNet"><span class="dot" id="netDot"></span><span id="netText">通信: OFF</span></div>
      </div>
    </header>

    <main>
      <div class="stage" id="stage">
        <canvas id="draw"></canvas>
        <canvas id="onion" aria-hidden="true"></canvas>
        <canvas id="play" aria-hidden="true"></canvas>
        <div class="badge" id="badge">コマ 1 / 60</div>
      </div>

      <section class="panel">
        <div class="tab on" id="tabKoma">
          <div class="box">
            <div class="mini">コマ</div>
            <input id="slider" type="range" min="0" max="59" value="0" />
          </div>

          <div class="row" style="margin-top:10px;">
            <button id="prev" class="btn sub">◀ 前</button>
            <button id="next" class="btn sub">次 ▶</button>
            <button id="list" class="btn sub">一覧</button>
          </div>

          <div class="box" style="margin-top:10px;">
            <div class="mini">部屋</div>
            <div class="row">
              <input id="room" type="text" placeholder="部屋ID" />
              <button id="copyRoom" class="btn sub" style="flex:0 0 auto; min-width:110px;">コピー</button>
            </div>
            <div class="row" style="margin-top:10px;">
              <button id="newRoom" class="btn sub">部屋を作る</button>
              <button id="rejoin" class="btn ok">入る/入り直す</button>
            </div>
          </div>
        </div>

        <div class="tab" id="tabKaku">
          <div class="box">
            <div class="mini">道具</div>
            <div class="row">
              <button id="pen" class="btn ok">ペン</button>
              <button id="erase" class="btn sub">消す</button>
              <button id="undo" class="btn sub">戻す</button>
            </div>
            <div class="row" style="margin-top:10px;">
              <button id="clear" class="btn bad">全消し</button>
              <button id="onionBtn" class="btn sub">前: ON</button>
            </div>
          </div>

          <div class="box" style="margin-top:10px;">
            <div class="mini">色 / 太さ</div>
            <div class="grid2">
              <input id="color" type="color" value="#141428" aria-label="色" />
              <div class="box" style="padding:10px;">
                <div class="mini" style="margin-bottom:6px;">太さ: <span id="w">6</span></div>
                <input id="size" type="range" min="1" max="40" value="6" />
              </div>
            </div>
          </div>
        </div>

        <div class="tab" id="tabMiru">
          <div class="box">
            <div class="mini">見る</div>
            <div class="row">
              <button id="playBtn" class="btn ok">▶ 見る</button>
              <button id="stopBtn" class="btn sub">■ 止める</button>
              <button id="loopBtn" class="btn sub">くり返し: OFF</button>
            </div>

            <div class="box" style="margin-top:10px;">
              <div class="mini">いま</div>
              <div style="display:flex; align-items:center; gap:10px;">
                <div style="font-weight:1000; min-width:60px;" id="pf">-</div>
                <div style="flex:1; height:10px; border-radius:999px; border:1px solid rgba(20,20,40,.12); background: rgba(106,124,255,.12); overflow:hidden;">
                  <div id="bar" style="height:100%; width:0%; background: linear-gradient(90deg, rgba(106,124,255,.85), rgba(255,92,200,.75));"></div>
                </div>
                <div style="font-weight:1000; min-width:62px; text-align:right;" id="pt">0.00</div>
              </div>
            </div>
          </div>
        </div>

        <div class="tab" id="tabMenu">
          <div class="box">
            <div class="mini">通信</div>
            <div class="row">
              <input id="wsBase" type="url" placeholder="https://サーバーURL（例）" />
              <button id="saveWs" class="btn sub" style="flex:0 0 auto; min-width:110px;">保存</button>
            </div>
            <div class="row" style="margin-top:10px;">
              <button id="connectBtn" class="btn ok">つなぐ</button>
              <button id="resyncBtn" class="btn sub">同期</button>
            </div>

            <div class="box" style="margin-top:10px;">
              <div class="mini">お題</div>
              <div style="font-weight:1000; font-size:16px;" id="odai">-</div>
              <div style="margin-top:6px; font-weight:900; color: rgba(20,20,40,.70);" id="odai2">-</div>

              <div class="row" style="margin-top:10px;">
                <button id="changeTheme" class="btn sub">お題を変える</button>
                <button id="saveGifBtn" class="btn ok">GIFで保存</button>
              </div>

              <div class="row" style="margin-top:10px;">
                <button id="resetBtn" class="btn bad">この端末の保存を消す</button>
              </div>
            </div>
          </div>
        </div>

        <div class="bar">
          <button class="tbtn on" id="tKoma">コマ</button>
          <button class="tbtn" id="tKaku">描く</button>
          <button class="tbtn" id="tMiru">見る</button>
          <button class="tbtn" id="tMenu">メニュー</button>
        </div>
      </section>
    </main>
  </div>

  <div class="back" id="back" aria-hidden="true">
    <div class="sheet" role="dialog" aria-modal="true">
      <div class="sheetTop">
        <div>コマ一覧</div>
        <button id="close" class="btn sub" style="flex:0 0 auto; min-width:92px; padding:10px 12px;">閉じる</button>
      </div>
      <div class="sheetGrid" id="grid"></div>
    </div>
  </div>

  <div class="toast" id="toast"><div class="t" id="toastText">-</div></div>

  <script>
    // ====== 固定設定 ======
    const RES = 256;
    const FPS = 12;
    const COUNT = 60;

    // ====== DOM ======
    const $ = (id) => document.getElementById(id);

    const stage = $("stage");
    const onion = $("onion");
    const draw  = $("draw");
    const play  = $("play");

    const badge = $("badge");
    const chipKoma = $("chipKoma");
    const themeLine = $("themeLine");

    const netDot = $("netDot");
    const netText = $("netText");

    const slider = $("slider");
    const prev = $("prev");
    const next = $("next");
    const list = $("list");

    const roomInp = $("room");
    const copyRoomBtn = $("copyRoom");
    const newRoomBtn = $("newRoom");
    const rejoinBtn = $("rejoin");

    const pen = $("pen");
    const erase = $("erase");
    const undo = $("undo");
    const clearBtn = $("clear");
    const onionBtn = $("onionBtn");
    const color = $("color");
    const size = $("size");
    const w = $("w");

    const playBtn = $("playBtn");
    const stopBtn = $("stopBtn");
    const loopBtn = $("loopBtn");
    const pf = $("pf");
    const pt = $("pt");
    const bar = $("bar");

    const wsBase = $("wsBase");
    const saveWs = $("saveWs");
    const connectBtn = $("connectBtn");
    const resyncBtn = $("resyncBtn");

    const odai = $("odai");
    const odai2 = $("odai2");
    const changeThemeBtn = $("changeTheme");
    const saveGifBtn = $("saveGifBtn");
    const resetBtn = $("resetBtn");

    const back = $("back");
    const close = $("close");
    const grid = $("grid");

    const tKoma = $("tKoma");
    const tKaku = $("tKaku");
    const tMiru = $("tMiru");
    const tMenu = $("tMenu");
    const tabKoma = $("tabKoma");
    const tabKaku = $("tabKaku");
    const tabMiru = $("tabMiru");
    const tabMenu = $("tabMenu");

    const toast = $("toast");
    const toastText = $("toastText");

    // ====== 状態 ======
    let octx, dctx, pctx;

    const LS_KEY = "anim5s_collab_v1";
    const LS_WS  = "anim5s_ws_base_v1";

    let state = {
      roomId: null,
      playerId: null,
      theme: null,
      cur: 0,
      tool: "pen",
      color: "#141428",
      size: 6,
      loop: false,
      onion: true,
      frames: Array.from({length: COUNT}, () => ({img:null})),
      logs: [] // 見えない
    };

    let isDown = false;
    let last = null;
    let undoStack = [];
    const UNDO_MAX = 18;

    let previewMode = "none"; // none / playing / paused
    let playStart = 0;
    let playPosSec = 0;
    let raf = 0;
    let imgs = [];

    // ====== WebSocket ======
    let ws = null;
    let wsWanted = false;
    let reconnectTimer = 0;
    let backoff = 600;

    // ====== Utils ======
    const clamp = (n,a,b)=>Math.max(a, Math.min(b,n));

    function toastShow(s){
      toastText.textContent = s;
      toast.classList.add("on");
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>toast.classList.remove("on"), 1600);
    }

    function log(s){
      state.logs.unshift(`${new Date().toLocaleTimeString()} ${s}`);
      if (state.logs.length > 200) state.logs.length = 200;
    }

    function randRoom(){
      const abc = "abcdefghjkmnpqrstuvwxyz23456789";
      let s = "";
      for (let i=0;i<7;i++) s += abc[(Math.random()*abc.length)|0];
      return s;
    }

    function parseQS(){
      const u = new URL(location.href);
      const room = u.searchParams.get("room");
      const server = u.searchParams.get("server");
      return { room, server };
    }

    function setQS(roomId){
      const u = new URL(location.href);
      u.searchParams.set("room", roomId);
      history.replaceState(null, "", u.toString());
    }

    async function copyText(s){
      if (navigator.clipboard?.writeText){
        try{ await navigator.clipboard.writeText(s); return; }catch{}
      }
      const ta = document.createElement("textarea");
      ta.value = s;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand("copy"); }catch{}
      ta.remove();
    }

    function wsBaseToWsUrl(base){
      base = (base||"").trim();
      if (!base) return "";
      try{
        if (base.startsWith("ws://") || base.startsWith("wss://")){
          const u = new URL(base);
          if (!u.pathname || u.pathname === "/") u.pathname = "/ws";
          return u.toString();
        }
        const u = new URL(base);
        if (u.protocol === "http:") u.protocol = "ws:";
        if (u.protocol === "https:") u.protocol = "wss:";
        if (!u.pathname || u.pathname === "/") u.pathname = "/ws";
        return u.toString();
      }catch{
        return "";
      }
    }

    function setNet(ok, bad=false){
      netDot.classList.toggle("on", ok);
      netDot.classList.toggle("bad", bad);
      netText.textContent = ok ? "通信: ON" : "通信: OFF";
    }

    function send(msg){
      if (!ws || ws.readyState !== 1) return false;
      try{
        ws.send(JSON.stringify(msg));
        return true;
      }catch{ return false; }
    }

    function connect(){
      clearTimeout(reconnectTimer);
      if (!wsWanted) return;

      const base = (localStorage.getItem(LS_WS) || "").trim();
      const url = wsBaseToWsUrl(base);
      if (!url){
        toastShow("サーバーURLがない");
        setNet(false, true);
        return;
      }

      if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;

      try{
        ws = new WebSocket(url);
      }catch{
        setNet(false, true);
        toastShow("つなげない");
        return;
      }

      ws.onopen = ()=>{
        backoff = 600;
        setNet(true);
        toastShow("つながった");
        const roomId = (roomInp.value || state.roomId || "").trim();
        if (roomId) joinRoom(roomId);
      };

      ws.onmessage = (ev)=>{
        let m = null;
        try{ m = JSON.parse(ev.data); }catch{ return; }
        if (!m || typeof m.t !== "string") return;

        if (m.t === "welcome"){
          state.playerId = m.playerId || state.playerId;
          log(`welcome ${state.playerId||"-"}`);
          return;
        }
        if (m.t === "room_state"){
          applyRoomState(m.data);
          return;
        }
        if (m.t === "frame_committed"){
          const d = m.data || {};
          const i = d.frameIndex|0;
          const img = d.img;
          if (i>=0 && i<COUNT && typeof img === "string"){
            state.frames[i].img = img;
            if (i === state.cur) renderFrame();
            renderGrid();
            renderOnion();
            if (d.by && d.by !== state.playerId){
              toastShow(`更新: コマ${i+1}`);
            }
          }
          if (d.theme) applyTheme(d.theme);
          return;
        }
        if (m.t === "theme_changed"){
          if (m.data?.theme) applyTheme(m.data.theme);
          toastShow("お題が変わった");
          return;
        }
        if (m.t === "error"){
          toastShow(m.message || "エラー");
          return;
        }
      };

      ws.onclose = ()=>{
        setNet(false);
        if (!wsWanted) return;
        scheduleReconnect();
      };
      ws.onerror = ()=>{
        setNet(false, true);
      };
    }

    function scheduleReconnect(){
      clearTimeout(reconnectTimer);
      reconnectTimer = setTimeout(()=>{
        connect();
        backoff = Math.min(8000, Math.floor(backoff*1.6));
      }, backoff);
    }

    function joinRoom(roomId){
      roomId = (roomId||"").trim();
      if (!roomId) return;

      state.roomId = roomId;
      roomInp.value = roomId;
      setQS(roomId);

      send({ v:1, t:"join", roomId });
      send({ v:1, t:"resync", roomId });
      toastShow(`部屋: ${roomId}`);
      log(`join ${roomId}`);
      saveLocalSoon();
    }

    function applyTheme(theme){
      state.theme = theme;
      const title = theme?.title || "-";
      const note  = theme?.note || "-";
      odai.textContent = title;
      odai2.textContent = note;
      themeLine.textContent = `お題：${title}`;
      saveLocalSoon();
    }

    function applyRoomState(d){
      if (!d) return;
      if (d.roomId) state.roomId = d.roomId;
      if (d.theme) applyTheme(d.theme);
      if (Array.isArray(d.frames) && d.frames.length === COUNT){
        for (let i=0;i<COUNT;i++){
          const img = d.frames[i];
          state.frames[i].img = (typeof img === "string") ? img : null;
        }
      }
      roomInp.value = state.roomId || "";
      updateTop();
      renderGrid();
      renderFrame();
      renderOnion();
      toastShow("同期した");
      log("resync");
      saveLocalSoon();
    }

    // ====== Canvas / UI ======
    function setup(){
      onion.width = RES; onion.height = RES;
      draw.width  = RES; draw.height  = RES;
      play.width  = RES; play.height  = RES;

      octx = onion.getContext("2d");
      dctx = draw.getContext("2d", { willReadFrequently:true });
      pctx = play.getContext("2d");

      octx.imageSmoothingEnabled = false;
      dctx.imageSmoothingEnabled = true;
      pctx.imageSmoothingEnabled = false;
    }

    function setTab(name){
      const map = {koma:tabKoma, kaku:tabKaku, miru:tabMiru, menu:tabMenu};
      const btns = {koma:tKoma, kaku:tKaku, miru:tMiru, menu:tMenu};
      Object.keys(map).forEach(k=>{
        map[k].classList.toggle("on", k===name);
        btns[k].classList.toggle("on", k===name);
      });
      if (name !== "miru") exitPreview();
    }

    function updateTop(){
      const t = `コマ ${state.cur+1} / ${COUNT}`;
      badge.textContent = t;
      $("chipKoma").textContent = t;
      slider.value = String(state.cur);
    }

    function updateTool(){
      const isPen = state.tool === "pen";
      pen.classList.toggle("ok", isPen);
      pen.classList.toggle("sub", !isPen);
      erase.classList.toggle("ok", !isPen);
      erase.classList.toggle("sub", isPen);

      w.textContent = String(state.size);
      size.value = String(state.size);
      color.value = state.color;

      onionBtn.textContent = `前: ${state.onion ? "ON" : "OFF"}`;
      document.documentElement.style.setProperty("--onionOpacity", state.onion ? ".20" : "0");

      loopBtn.textContent = `くり返し: ${state.loop ? "ON" : "OFF"}`;
    }

    function renderOnion(){
      octx.clearRect(0,0,RES,RES);
      if (!state.onion) return;
      const prevI = state.cur - 1;
      if (prevI < 0) return;
      const imgUrl = state.frames[prevI]?.img;
      if (!imgUrl) return;

      const im = new Image();
      const cur = state.cur;
      im.decoding = "async";
      im.onload = () => {
        if (state.cur !== cur) return;
        octx.clearRect(0,0,RES,RES);
        octx.drawImage(im, 0, 0, RES, RES);
      };
      im.src = imgUrl;
    }

    function renderFrame(){
      dctx.clearRect(0,0,RES,RES);
      undoStack = [];

      const imgUrl = state.frames[state.cur]?.img;
      if (!imgUrl){
        renderOnion();
        return;
      }

      const im = new Image();
      const cur = state.cur;
      im.decoding = "async";
      im.onload = () => {
        if (state.cur !== cur) return;
        dctx.clearRect(0,0,RES,RES);
        dctx.drawImage(im, 0, 0, RES, RES);
        renderOnion();
      };
      im.src = imgUrl;
    }

    function renderGrid(){
      if (!grid._made){
        grid._made = true;
        grid.innerHTML = "";
        for (let i=0;i<COUNT;i++){
          const b = document.createElement("button");
          b.className = "f";
          b.textContent = String(i+1);
          b.addEventListener("click", ()=>{
            closeList();
            select(i);
          });
          grid.appendChild(b);
        }
      }
      const buttons = grid.children;
      for (let i=0;i<COUNT;i++){
        const b = buttons[i];
        b.classList.toggle("on", i === state.cur);
        b.classList.toggle("empty", !state.frames[i]?.img);
      }
    }

    function pushUndo(){
      try{
        const snap = dctx.getImageData(0,0,RES,RES);
        undoStack.push(snap);
        if (undoStack.length > UNDO_MAX) undoStack.shift();
      }catch{}
    }

    function doUndo(){
      const snap = undoStack.pop();
      if (!snap) return;
      dctx.putImageData(snap, 0, 0);
      commit("戻す");
    }

    function compositeToPngDataUrl(){
      const c = document.createElement("canvas");
      c.width = RES; c.height = RES;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,RES,RES);
      ctx.drawImage(draw, 0, 0);
      return c.toDataURL("image/png");
    }

    function saveLocalSoon(){
      clearTimeout(saveLocalSoon._t);
      saveLocalSoon._t = setTimeout(saveLocal, 250);
    }

    function saveLocal(){
      try{
        const data = {
          v: 1,
          at: Date.now(),
          roomId: state.roomId,
          theme: state.theme,
          cur: state.cur,
          tool: state.tool,
          color: state.color,
          size: state.size,
          loop: state.loop,
          onion: state.onion,
          frames: state.frames.map(f=>f.img)
        };
        localStorage.setItem(LS_KEY, JSON.stringify(data));
      }catch{}
    }

    function loadLocal(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return false;
        const d = JSON.parse(raw);
        if (!d || d.v !== 1) return false;

        if (Array.isArray(d.frames) && d.frames.length === COUNT){
          for (let i=0;i<COUNT;i++){
            const img = d.frames[i];
            state.frames[i].img = (typeof img === "string") ? img : null;
          }
        }
        if (d.theme) state.theme = d.theme;
        if (typeof d.roomId === "string") state.roomId = d.roomId;
        if (Number.isInteger(d.cur)) state.cur = clamp(d.cur, 0, COUNT-1);
        if (d.tool === "pen" || d.tool === "erase") state.tool = d.tool;
        if (typeof d.color === "string") state.color = d.color;
        if (Number.isFinite(d.size)) state.size = clamp(d.size, 1, 40);
        state.loop = !!d.loop;
        state.onion = !!d.onion;
        return true;
      }catch{ return false; }
    }

    function commit(why){
      const img = compositeToPngDataUrl();
      state.frames[state.cur].img = img;
      renderGrid();
      renderOnion();
      updateTop();
      saveLocalSoon();

      if (ws && ws.readyState === 1 && state.roomId){
        send({ v:1, t:"submit_frame", roomId: state.roomId, frameIndex: state.cur, img });
      }

      log(`更新: コマ${state.cur+1} (${why})`);
    }

    function pointerPos(e){
      const rect = draw.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width  * RES;
      const y = (e.clientY - rect.top)  / rect.height * RES;
      return {x, y};
    }

    function begin(pt){
      pushUndo();
      isDown = true;
      last = pt;

      dctx.lineCap = "round";
      dctx.lineJoin = "round";
      dctx.lineWidth = state.size;

      if (state.tool === "erase"){
        dctx.globalCompositeOperation = "destination-out";
        dctx.strokeStyle = "rgba(0,0,0,1)";
      }else{
        dctx.globalCompositeOperation = "source-over";
        dctx.strokeStyle = state.color;
      }

      dctx.beginPath();
      dctx.moveTo(pt.x, pt.y);
      dctx.lineTo(pt.x + 0.01, pt.y + 0.01);
      dctx.stroke();
    }

    function move(pt){
      if (!isDown || !last) return;
      dctx.beginPath();
      dctx.moveTo(last.x, last.y);
      dctx.lineTo(pt.x, pt.y);
      dctx.stroke();
      last = pt;
    }

    function end(){
      if (!isDown) return;
      isDown = false;
      last = null;
      commit("描く");
    }

    function select(i){
      i = clamp(i, 0, COUNT-1);
      state.cur = i;
      updateTop();
      renderFrame();
      renderGrid();
      saveLocalSoon();
      log(`移動: コマ${i+1}`);
    }

    // ====== 再生（停止したらそのフレームで止まる） ======
    function prepImgs(){
      imgs = state.frames.map(f=>{
        if (!f.img) return null;
        const im = new Image();
        im.decoding = "async";
        im.src = f.img;
        return im;
      });
    }

    function paintPlay(idx){
      pctx.clearRect(0,0,RES,RES);
      pctx.fillStyle = "#fff";
      pctx.fillRect(0,0,RES,RES);
      const im = imgs[idx];
      if (!im) return;
      if (im.complete && im.naturalWidth > 0){
        pctx.imageSmoothingEnabled = false;
        pctx.drawImage(im, 0, 0, RES, RES);
      }
    }

    function startPlay(){
      if (previewMode === "playing") return;
      prepImgs();
      stage.classList.add("preview");

      if (previewMode === "paused"){
        playStart = performance.now() - playPosSec * 1000;
      }else{
        playPosSec = 0;
        playStart = performance.now();
      }
      previewMode = "playing";
      tick();
    }

    function pausePlay(){
      if (previewMode !== "playing") return;
      previewMode = "paused";
      cancelAnimationFrame(raf);
    }

    function exitPreview(){
      if (previewMode === "none") return;
      previewMode = "none";
      cancelAnimationFrame(raf);
      stage.classList.remove("preview");
      pf.textContent = "-";
      pt.textContent = "0.00";
      bar.style.width = "0%";
    }

    function tick(){
      if (previewMode !== "playing") return;

      const nowP = performance.now();
      const sec = (nowP - playStart) / 1000;
      playPosSec = sec;

      const dur = COUNT / FPS;
      let fi = Math.floor(sec * FPS);

      if (fi >= COUNT){
        if (state.loop){
          playStart = nowP;
          playPosSec = 0;
          fi = 0;
        }else{
          fi = COUNT - 1;
          paintPlay(fi);
          pf.textContent = `コマ${fi+1}`;
          pt.textContent = dur.toFixed(2);
          bar.style.width = "100%";
          previewMode = "paused";
          return;
        }
      }

      paintPlay(fi);
      pf.textContent = `コマ${fi+1}`;
      pt.textContent = sec.toFixed(2);
      bar.style.width = `${clamp((sec/dur)*100, 0, 100)}%`;

      raf = requestAnimationFrame(tick);
    }

    function openList(){
      back.classList.add("on");
      back.setAttribute("aria-hidden", "false");
    }
    function closeList(){
      back.classList.remove("on");
      back.setAttribute("aria-hidden", "true");
    }

    // ====== GIF 保存（Web-safe 256色） ======
    function buildWebSafePalette256(){
      const pal = new Uint8Array(256*3);
      const steps = [0,51,102,153,204,255];
      let idx = 0;
      for (let r=0;r<6;r++){
        for (let g=0;g<6;g++){
          for (let b=0;b<6;b++){
            pal[idx*3+0] = steps[r];
            pal[idx*3+1] = steps[g];
            pal[idx*3+2] = steps[b];
            idx++;
          }
        }
      }
      for (; idx<256; idx++){
        pal[idx*3+0] = 255;
        pal[idx*3+1] = 255;
        pal[idx*3+2] = 255;
      }
      return pal;
    }

    function quantWebSafeIndex(r,g,b){
      const r6 = Math.max(0, Math.min(5, Math.round(r/51)));
      const g6 = Math.max(0, Math.min(5, Math.round(g/51)));
      const b6 = Math.max(0, Math.min(5, Math.round(b/51)));
      return (r6*36 + g6*6 + b6) & 255;
    }

    class ChunkWriter{
      constructor(cap=1<<20){
        this.buf = new Uint8Array(cap);
        this.pos = 0;
        this.chunks = [];
      }
      byte(v){
        if (this.pos >= this.buf.length) this.flush();
        this.buf[this.pos++] = v & 255;
      }
      word(v){ this.byte(v); this.byte(v>>8); }
      str(s){ for (let i=0;i<s.length;i++) this.byte(s.charCodeAt(i)); }
      bytes(u8){
        let i=0;
        while (i < u8.length){
          const room = this.buf.length - this.pos;
          if (room === 0){ this.flush(); continue; }
          const take = Math.min(room, u8.length - i);
          this.buf.set(u8.subarray(i, i+take), this.pos);
          this.pos += take;
          i += take;
        }
      }
      flush(){
        if (this.pos > 0){
          this.chunks.push(this.buf.slice(0, this.pos));
          this.pos = 0;
        }
      }
      blob(type){
        this.flush();
        return new Blob(this.chunks, {type});
      }
    }

    function writeSubBlocks(w, data){
      let i=0;
      while (i < data.length){
        const n = Math.min(255, data.length - i);
        w.byte(n);
        w.bytes(data.subarray(i, i+n));
        i += n;
      }
      w.byte(0);
    }

    function lzwEncodeWithResets(indices, minCodeSize, resetEvery){
      const CLEAR = 1 << minCodeSize;
      const EOI   = CLEAR + 1;
      const MAX   = 4095;

      let next = EOI + 1;
      let codeSize = minCodeSize + 1;
      const dict = new Map();

      const out = [];
      let cur = 0;
      let bits = 0;

      const write = (code)=>{
        cur |= (code << bits);
        bits += codeSize;
        while (bits >= 8){
          out.push(cur & 255);
          cur >>= 8;
          bits -= 8;
        }
      };

      const reset = ()=>{
        dict.clear();
        next = EOI + 1;
        codeSize = minCodeSize + 1;
      };

      reset();
      write(CLEAR);

      let prefix = indices[0];

      for (let i=1;i<indices.length;i++){
        if (resetEvery && (i % resetEvery) === 0){
          write(prefix);
          write(CLEAR);
          reset();
          prefix = indices[i];
          continue;
        }

        const k = indices[i];
        const key = (prefix << 8) | k;
        const hit = dict.get(key);
        if (hit !== undefined){
          prefix = hit;
        }else{
          write(prefix);

          if (next <= MAX){
            dict.set(key, next++);
            if (next === (1 << codeSize) && codeSize < 12) codeSize++;
          }else{
            write(CLEAR);
            reset();
          }
          prefix = k;
        }
      }

      write(prefix);
      write(EOI);
      if (bits > 0) out.push(cur & 255);
      return new Uint8Array(out);
    }

    function makeDelays(){
      const delays = new Uint16Array(COUNT);
      const ideal = 100 / FPS;
      const target = 500;
      let rem = 0;
      let sum = 0;
      for (let i=0;i<COUNT;i++){
        rem += ideal;
        let d = Math.floor(rem + 1e-6);
        rem -= d;
        if (d < 1) d = 1;
        delays[i] = d;
        sum += d;
      }
      const fix = target - sum;
      delays[COUNT-1] = Math.max(1, delays[COUNT-1] + fix);
      return delays;
    }

    function loadImage(url){
      return new Promise((resolve, reject)=>{
        const im = new Image();
        im.decoding = "async";
        im.onload = ()=> resolve(im);
        im.onerror = reject;
        im.src = url;
      });
    }

    async function saveAsGif(){
      saveGifBtn.disabled = true;
      try{
        toastShow("GIFを作る…");

        const pal = buildWebSafePalette256();
        const delays = makeDelays();
        const bgIndex = 215;

        const w = new ChunkWriter(1<<20);

        w.str("GIF89a");
        w.word(RES); w.word(RES);
        w.byte(0xF7);
        w.byte(bgIndex);
        w.byte(0);
        w.bytes(pal);

        w.byte(0x21); w.byte(0xFF); w.byte(11);
        w.str("NETSCAPE2.0");
        w.byte(3); w.byte(1); w.word(0); w.byte(0);

        const c = document.createElement("canvas");
        c.width = RES; c.height = RES;
        const ctx = c.getContext("2d", { willReadFrequently:true });
        ctx.imageSmoothingEnabled = false;

        for (let fi=0; fi<COUNT; fi++){
          toastShow(`GIF ${fi+1}/${COUNT}`);

          ctx.clearRect(0,0,RES,RES);
          ctx.fillStyle = "#fff";
          ctx.fillRect(0,0,RES,RES);

          const url = state.frames[fi]?.img;
          if (url){
            const im = await loadImage(url);
            ctx.drawImage(im, 0, 0, RES, RES);
          }

          const data = ctx.getImageData(0,0,RES,RES).data;
          const idxs = new Uint8Array(RES*RES);
          let p = 0;
          for (let i=0; i<data.length; i+=4){
            idxs[p++] = quantWebSafeIndex(data[i], data[i+1], data[i+2]);
          }

          w.byte(0x21); w.byte(0xF9); w.byte(4);
          w.byte(0b00001000);
          w.word(delays[fi]);
          w.byte(0);
          w.byte(0);

          w.byte(0x2C);
          w.word(0); w.word(0);
          w.word(RES); w.word(RES);
          w.byte(0);

          const minCodeSize = 8;
          w.byte(minCodeSize);
          const lzw = lzwEncodeWithResets(idxs, minCodeSize, RES);
          writeSubBlocks(w, lzw);
        }

        w.byte(0x3B);

        const blob = w.blob("image/gif");
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const name = (state.theme?.title || "anim").replace(/[^\p{L}\p{N}_-]/gu, "_");
        a.href = url;
        a.download = `5s_${name}_${Date.now()}.gif`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        toastShow("GIFを保存した");
      }catch(e){
        console.error(e);
        toastShow("GIFがダメだった");
      }finally{
        saveGifBtn.disabled = false;
      }
    }

    function resetLocalOnly(){
      if (!confirm("この端末の保存だけ消します。いいですか？")) return;
      try{ localStorage.removeItem(LS_KEY); }catch{}
      toastShow("消した");
    }

    // ====== イベント ======
    tKoma.addEventListener("click", ()=>setTab("koma"));
    tKaku.addEventListener("click", ()=>setTab("kaku"));
    tMiru.addEventListener("click", ()=>setTab("miru"));
    tMenu.addEventListener("click", ()=>setTab("menu"));

    slider.addEventListener("input", ()=> {
      state.cur = Number(slider.value);
      updateTop();
      renderFrame();
      renderGrid();
    });
    slider.addEventListener("change", ()=> { select(Number(slider.value)); });

    prev.addEventListener("click", ()=> select(state.cur - 1));
    next.addEventListener("click", ()=> select(state.cur + 1));

    list.addEventListener("click", openList);
    close.addEventListener("click", closeList);
    back.addEventListener("click", (e)=>{ if (e.target === back) closeList(); });

    newRoomBtn.addEventListener("click", ()=>{
      const r = randRoom();
      roomInp.value = r;
      state.roomId = r;
      setQS(r);
      toastShow("部屋を作った");
      saveLocalSoon();
    });

    rejoinBtn.addEventListener("click", ()=>{
      const r = (roomInp.value||"").trim();
      if (!r){ toastShow("部屋IDがない"); return; }
      joinRoom(r);
    });

    copyRoomBtn.addEventListener("click", async ()=>{
      const u = new URL(location.href);
      const r = (roomInp.value||"").trim();
      if (r) u.searchParams.set("room", r);
      await copyText(u.toString());
      toastShow("コピーした");
    });

    pen.addEventListener("click", ()=>{ state.tool="pen"; updateTool(); saveLocalSoon(); });
    erase.addEventListener("click", ()=>{ state.tool="erase"; updateTool(); saveLocalSoon(); });

    undo.addEventListener("click", ()=>{ doUndo(); });
    clearBtn.addEventListener("click", ()=>{
      pushUndo();
      dctx.clearRect(0,0,RES,RES);
      commit("全消し");
    });

    onionBtn.addEventListener("click", ()=>{
      state.onion = !state.onion;
      updateTool();
      renderOnion();
      saveLocalSoon();
    });

    color.addEventListener("input", ()=>{ state.color = String(color.value); saveLocalSoon(); });
    size.addEventListener("input", ()=>{
      state.size = clamp(Number(size.value), 1, 40);
      w.textContent = String(state.size);
      saveLocalSoon();
    });

    playBtn.addEventListener("click", startPlay);
    stopBtn.addEventListener("click", pausePlay);
    loopBtn.addEventListener("click", ()=>{ state.loop=!state.loop; updateTool(); saveLocalSoon(); });

    saveWs.addEventListener("click", ()=>{
      const v = (wsBase.value||"").trim();
      if (!v){ toastShow("空"); return; }
      localStorage.setItem(LS_WS, v);
      toastShow("保存した");
    });

    connectBtn.addEventListener("click", ()=>{
      wsWanted = true;
      connect();
    });

    resyncBtn.addEventListener("click", ()=>{
      if (!state.roomId){ toastShow("部屋がない"); return; }
      send({ v:1, t:"resync", roomId: state.roomId });
    });

    changeThemeBtn.addEventListener("click", ()=>{
      if (!state.roomId){ toastShow("部屋がない"); return; }
      send({ v:1, t:"change_theme", roomId: state.roomId });
    });

    saveGifBtn.addEventListener("click", saveAsGif);
    resetBtn.addEventListener("click", resetLocalOnly);

    draw.addEventListener("pointerdown", (e)=>{
      if (previewMode !== "none") return;
      draw.setPointerCapture?.(e.pointerId);
      begin(pointerPos(e));
      e.preventDefault();
    });
    draw.addEventListener("pointermove", (e)=>{
      if (!isDown || previewMode !== "none") return;
      move(pointerPos(e));
      e.preventDefault();
    });
    const endAll = ()=> end();
    draw.addEventListener("pointerup", endAll);
    draw.addEventListener("pointercancel", endAll);
    draw.addEventListener("pointerleave", endAll);

    // ====== 起動 ======
    (function init(){
      setup();

      const qs = parseQS();
      const loaded = loadLocal();

      if (qs.server){
        localStorage.setItem(LS_WS, qs.server);
      }
      wsBase.value = localStorage.getItem(LS_WS) || "";

      const room = (qs.room || state.roomId || "").trim();
      if (room){
        state.roomId = room;
        roomInp.value = room;
        setQS(room);
      }else{
        const r = randRoom();
        state.roomId = r;
        roomInp.value = r;
        setQS(r);
      }

      if (state.theme){
        applyTheme(state.theme);
      }else{
        applyTheme({ title:"-", note:"-" });
      }

      updateTool();
      renderGrid();
      updateTop();
      renderFrame();
      setTab("koma");

      setNet(false);

      if (loaded) toastShow("前のつづき");

      if ((localStorage.getItem(LS_WS)||"").trim()){
        wsWanted = true;
        connect();
      }
    })();
  </script>
</body>
</html>
